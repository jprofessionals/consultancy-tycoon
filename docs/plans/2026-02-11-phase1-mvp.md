# Phase 1 MVP — Core Clicker Loop Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a playable clicker prototype where you complete coding tasks in a fake IDE to earn money, bid on client contracts, and buy skills that improve your efficiency.

**Architecture:** Separation of logic and UI. Autoloads hold global state (GameState) and a signal bus (EventBus). Game logic lives in pure GDScript classes testable with GUT. UI scenes observe state through signals and call logic methods. All UI is built programmatically from minimal .tscn root scenes.

**Tech Stack:** Godot 4.6, GDScript, GUT (Godot Unit Test) for testing, GL Compatibility renderer.

---

### Task 1: Project Foundation & Test Framework

**Files:**
- Create: `addons/gut/` (installed from GitHub)
- Create: `.gutconfig.json`
- Create: `test/unit/test_smoke.gd`
- Modify: `project.godot`

**Step 1: Create folder structure**

```bash
mkdir -p src/autoload src/data src/ide src/ui test/unit assets
```

**Step 2: Install GUT testing framework**

```bash
git clone --depth 1 --branch v9.3.0 https://github.com/bitwes/Gut.git /tmp/gut-install
mkdir -p addons
cp -r /tmp/gut-install/addons/gut addons/gut
rm -rf /tmp/gut-install
```

**Step 3: Configure GUT**

Create `.gutconfig.json`:
```json
{
    "dirs": ["res://test/unit/"],
    "prefix": "test_",
    "suffix": ".gd",
    "should_exit": true,
    "should_exit_on_success": true,
    "log_level": 1
}
```

**Step 4: Enable GUT plugin in project.godot**

Add to `project.godot`:
```ini
[editor_plugins]

enabled=PackedStringArray("res://addons/gut/plugin.cfg")
```

**Step 5: Write smoke test**

Create `test/unit/test_smoke.gd`:
```gdscript
extends GutTest

func test_godot_is_running():
	assert_true(true, "Godot test framework is working")

func test_basic_math():
	assert_eq(2 + 2, 4, "Basic arithmetic works")
```

**Step 6: Run tests to verify GUT works**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: 2 tests pass, 0 failures

**Step 7: Commit**

```bash
git add addons/gut .gutconfig.json test/unit/test_smoke.gd project.godot src/ assets/
git commit -m "feat: set up project structure and GUT test framework"
```

---

### Task 2: Event Bus & Game State Autoloads

**Files:**
- Create: `src/autoload/event_bus.gd`
- Create: `src/autoload/game_state.gd`
- Create: `test/unit/test_game_state.gd`
- Modify: `project.godot`

**Step 1: Write failing tests for GameState**

Create `test/unit/test_game_state.gd`:
```gdscript
extends GutTest

var state: Node

func before_each():
	state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)

func test_initial_money_is_zero():
	assert_eq(state.money, 0.0)

func test_add_money():
	state.add_money(100.0)
	assert_eq(state.money, 100.0)

func test_spend_money_success():
	state.add_money(200.0)
	var result = state.spend_money(150.0)
	assert_true(result)
	assert_eq(state.money, 50.0)

func test_spend_money_insufficient():
	state.add_money(50.0)
	var result = state.spend_money(100.0)
	assert_false(result)
	assert_eq(state.money, 50.0)

func test_initial_reputation_is_zero():
	assert_eq(state.reputation, 0.0)

func test_add_reputation():
	state.add_reputation(10.0)
	assert_eq(state.reputation, 10.0)
```

**Step 2: Run tests to verify they fail**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: FAIL — `game_state.gd` doesn't exist yet

**Step 3: Create EventBus**

Create `src/autoload/event_bus.gd`:
```gdscript
extends Node

# Coding loop signals
signal task_started(task)
signal task_phase_changed(phase)
signal task_completed(task, payout)
signal click_performed(progress_delta)

# Client signals
signal contract_offered(contract)
signal contract_bid_result(contract, success)

# Skill signals
signal skill_purchased(skill_id)

# Economy signals
signal money_changed(new_amount)
signal reputation_changed(new_amount)
```

**Step 4: Create GameState**

Create `src/autoload/game_state.gd`:
```gdscript
extends Node

var money: float = 0.0
var reputation: float = 0.0
var skills: Dictionary = {}

func add_money(amount: float) -> void:
	money += amount
	EventBus.money_changed.emit(money)

func spend_money(amount: float) -> bool:
	if money < amount:
		return false
	money -= amount
	EventBus.money_changed.emit(money)
	return true

func add_reputation(amount: float) -> void:
	reputation += amount
	EventBus.reputation_changed.emit(reputation)

func get_skill_level(skill_id: String) -> int:
	return skills.get(skill_id, 0)

func set_skill_level(skill_id: String, level: int) -> void:
	skills[skill_id] = level
	EventBus.skill_purchased.emit(skill_id)
```

**Step 5: Run tests to verify they pass**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All 6 tests pass

**Step 6: Register autoloads in project.godot**

Add to `project.godot` under `[application]`:
```ini
[autoload]

EventBus="*res://src/autoload/event_bus.gd"
GameState="*res://src/autoload/game_state.gd"
```

**Step 7: Commit**

```bash
git add src/autoload/ test/unit/test_game_state.gd project.godot
git commit -m "feat: add EventBus and GameState autoloads"
```

---

### Task 3: Coding Task Data Model

**Files:**
- Create: `src/data/coding_task.gd`
- Create: `src/data/task_factory.gd`
- Create: `test/unit/test_coding_task.gd`

**Step 1: Write failing tests**

Create `test/unit/test_coding_task.gd`:
```gdscript
extends GutTest

func test_task_creation():
	var task = load("res://src/data/coding_task.gd").new()
	task.title = "Fix auth bug"
	task.difficulty = 2
	task.payout = 50.0
	task.total_clicks = 10
	assert_eq(task.title, "Fix auth bug")
	assert_eq(task.difficulty, 2)
	assert_eq(task.payout, 50.0)
	assert_eq(task.total_clicks, 10)

func test_task_review_chance_scales_with_difficulty():
	var task = load("res://src/data/coding_task.gd").new()
	task.difficulty = 1
	var easy_chance = task.get_review_reject_chance()
	task.difficulty = 5
	var hard_chance = task.get_review_reject_chance()
	assert_gt(hard_chance, easy_chance, "Harder tasks should have higher reject chance")

func test_task_conflict_chance_scales_with_difficulty():
	var task = load("res://src/data/coding_task.gd").new()
	task.difficulty = 1
	var easy_chance = task.get_conflict_chance()
	task.difficulty = 5
	var hard_chance = task.get_conflict_chance()
	assert_gt(hard_chance, easy_chance, "Harder tasks should have higher conflict chance")

func test_task_factory_generates_valid_task():
	var factory = load("res://src/data/task_factory.gd").new()
	var task = factory.generate_task(1)
	assert_ne(task.title, "", "Task should have a title")
	assert_gt(task.payout, 0.0, "Task should have positive payout")
	assert_gt(task.total_clicks, 0, "Task should require clicks")

func test_task_factory_harder_tiers_pay_more():
	var factory = load("res://src/data/task_factory.gd").new()
	var easy = factory.generate_task(1)
	var hard = factory.generate_task(5)
	assert_gt(hard.payout, easy.payout, "Higher tier should pay more")
```

**Step 2: Run tests to verify they fail**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: FAIL

**Step 3: Create CodingTask resource**

Create `src/data/coding_task.gd`:
```gdscript
extends Resource
class_name CodingTask

var title: String = ""
var description: String = ""
var difficulty: int = 1  # 1-10
var payout: float = 0.0
var total_clicks: int = 10
var required_skills: Dictionary = {}  # skill_id -> min_level

func get_review_reject_chance() -> float:
	return clampf(0.1 + difficulty * 0.08, 0.1, 0.9)

func get_conflict_chance() -> float:
	return clampf(difficulty * 0.06, 0.0, 0.5)
```

**Step 4: Create TaskFactory**

Create `src/data/task_factory.gd`:
```gdscript
extends RefCounted
class_name TaskFactory

const TASK_TEMPLATES = [
	"Fix authentication bug",
	"Add payment endpoint",
	"Refactor database queries",
	"Implement search feature",
	"Update REST API",
	"Fix CSS layout issue",
	"Add input validation",
	"Optimize image loading",
	"Write migration script",
	"Add logging middleware",
	"Fix race condition",
	"Implement caching layer",
	"Add rate limiting",
	"Refactor error handling",
	"Build notification service",
]

func generate_task(tier: int) -> CodingTask:
	var task = CodingTask.new()
	task.title = TASK_TEMPLATES[randi() % TASK_TEMPLATES.size()]
	task.difficulty = clampi(tier + randi_range(-1, 1), 1, 10)
	task.payout = tier * 25.0 + randf_range(0, tier * 10.0)
	task.total_clicks = 8 + tier * 4 + randi_range(0, 4)
	return task
```

**Step 5: Run tests to verify they pass**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All pass

**Step 6: Commit**

```bash
git add src/data/ test/unit/test_coding_task.gd
git commit -m "feat: add CodingTask data model and TaskFactory"
```

---

### Task 4: Coding Loop State Machine

**Files:**
- Create: `src/logic/coding_loop.gd`
- Create: `test/unit/test_coding_loop.gd`

**Step 1: Write failing tests**

Create `test/unit/test_coding_loop.gd`:
```gdscript
extends GutTest

var loop

func before_each():
	loop = load("res://src/logic/coding_loop.gd").new()

func test_initial_state_is_idle():
	assert_eq(loop.state, loop.State.IDLE)

func test_start_task_enters_writing():
	var task = CodingTask.new()
	task.total_clicks = 5
	loop.start_task(task)
	assert_eq(loop.state, loop.State.WRITING)

func test_click_increases_progress():
	var task = CodingTask.new()
	task.total_clicks = 10
	loop.start_task(task)
	loop.perform_click(1.0)
	assert_gt(loop.progress, 0.0)

func test_writing_completes_at_full_progress():
	var task = CodingTask.new()
	task.total_clicks = 3
	task.difficulty = 1
	loop.start_task(task)
	# Force past writing phase
	for i in range(5):
		loop.perform_click(1.0)
	assert_ne(loop.state, loop.State.WRITING, "Should have left WRITING state")

func test_click_power_affects_progress():
	var task = CodingTask.new()
	task.total_clicks = 10
	loop.start_task(task)
	loop.perform_click(1.0)
	var normal_progress = loop.progress

	loop.reset()
	loop.start_task(task)
	loop.perform_click(3.0)
	assert_gt(loop.progress, normal_progress, "Higher click power = more progress")

func test_complete_task_returns_to_idle():
	var task = CodingTask.new()
	task.total_clicks = 1
	task.difficulty = 1
	loop.start_task(task)
	# Force completion through all phases
	loop.force_complete()
	assert_eq(loop.state, loop.State.IDLE)

func test_review_approved_skips_to_merge_check():
	var task = CodingTask.new()
	task.total_clicks = 1
	task.difficulty = 1
	loop.start_task(task)
	# Force to review state
	loop.progress = 1.0
	loop._advance_from_writing()
	assert_eq(loop.state, loop.State.REVIEWING)
	# Simulate approval
	loop.resolve_review(true)
	# Should be in CONFLICT check or COMPLETE
	assert_true(
		loop.state == loop.State.CONFLICT or loop.state == loop.State.COMPLETE,
		"After review approval should check for conflict or complete"
	)

func test_review_rejected_stays_in_review():
	var task = CodingTask.new()
	task.difficulty = 1
	task.total_clicks = 1
	loop.start_task(task)
	loop.progress = 1.0
	loop._advance_from_writing()
	loop.resolve_review(false)
	assert_eq(loop.state, loop.State.FIXING, "Rejection should enter FIXING state")

func test_conflict_resolution():
	var task = CodingTask.new()
	task.difficulty = 1
	task.total_clicks = 1
	loop.start_task(task)
	loop.state = loop.State.CONFLICT
	loop._setup_conflict()
	var correct = loop.conflict_correct_side
	loop.resolve_conflict(correct)
	assert_eq(loop.state, loop.State.COMPLETE)

func test_wrong_conflict_pick_adds_penalty():
	var task = CodingTask.new()
	task.difficulty = 1
	task.total_clicks = 1
	loop.start_task(task)
	loop.state = loop.State.CONFLICT
	loop._setup_conflict()
	var wrong = "right" if loop.conflict_correct_side == "left" else "left"
	loop.resolve_conflict(wrong)
	assert_eq(loop.state, loop.State.FIXING, "Wrong pick should require fixing")
```

**Step 2: Run tests to verify they fail**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: FAIL

**Step 3: Implement CodingLoop**

Create `src/logic/coding_loop.gd`:
```gdscript
extends RefCounted
class_name CodingLoop

enum State { IDLE, WRITING, REVIEWING, FIXING, CONFLICT, COMPLETE }

var state: State = State.IDLE
var progress: float = 0.0
var current_task: CodingTask = null
var review_changes_needed: int = 0
var conflict_correct_side: String = ""

signal state_changed(new_state: State)
signal progress_changed(new_progress: float)
signal review_result(approved: bool, comment: String)
signal conflict_appeared(left_code: String, right_code: String)
signal task_done(task: CodingTask)

func start_task(task: CodingTask) -> void:
	current_task = task
	progress = 0.0
	_set_state(State.WRITING)

func perform_click(click_power: float) -> void:
	if state == State.WRITING:
		progress += click_power / current_task.total_clicks
		progress_changed.emit(progress)
		if progress >= 1.0:
			progress = 1.0
			_advance_from_writing()
	elif state == State.FIXING:
		review_changes_needed -= 1
		if review_changes_needed <= 0:
			_advance_from_writing()

func _advance_from_writing() -> void:
	_set_state(State.REVIEWING)

func resolve_review(approved: bool) -> void:
	if state != State.REVIEWING:
		return
	if approved:
		_check_for_conflict()
	else:
		review_changes_needed = randi_range(1, 3)
		review_result.emit(false, "Changes requested (%d fixes needed)" % review_changes_needed)
		_set_state(State.FIXING)

func _check_for_conflict() -> void:
	var conflict_chance = current_task.get_conflict_chance()
	if randf() < conflict_chance:
		_set_state(State.CONFLICT)
		_setup_conflict()
	else:
		_complete_task()

func _setup_conflict() -> void:
	conflict_correct_side = "left" if randi() % 2 == 0 else "right"
	conflict_appeared.emit("<<<< LOCAL\nvar result = validate()", "<<<< REMOTE\nvar result = check()")

func resolve_conflict(chosen_side: String) -> void:
	if state != State.CONFLICT:
		return
	if chosen_side == conflict_correct_side:
		_complete_task()
	else:
		review_changes_needed = 1
		_set_state(State.FIXING)

func _complete_task() -> void:
	_set_state(State.COMPLETE)
	task_done.emit(current_task)

func force_complete() -> void:
	_complete_task()

func reset() -> void:
	state = State.IDLE
	progress = 0.0
	current_task = null

func _set_state(new_state: State) -> void:
	state = new_state
	state_changed.emit(new_state)
```

**Step 4: Run tests to verify they pass**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All pass

**Step 5: Commit**

```bash
git add src/logic/ test/unit/test_coding_loop.gd
git commit -m "feat: add CodingLoop state machine with tests"
```

---

### Task 5: IDE Interface — Writing Phase

**Files:**
- Create: `src/ide/fake_code.gd`
- Create: `src/ide/ide_interface.gd`
- Create: `src/ide/ide_interface.tscn`

**Step 1: Create fake code snippets data**

Create `src/ide/fake_code.gd`:
```gdscript
extends RefCounted
class_name FakeCode

const SNIPPETS = [
	["func validate_auth_token(token: String) -> bool:", "    var decoded = jwt.decode(token)", "    if decoded.exp < Time.get_unix_time():", "        return false", "    return decoded.issuer == VALID_ISSUER"],
	["func process_payment(amount: float, currency: String):", "    var tx = PaymentGateway.create()", "    tx.set_amount(amount)", "    tx.set_currency(currency)", "    return tx.execute()"],
	["class UserRepository:", "    var _db: Database", "", "    func find_by_email(email: String) -> User:", "        var query = _db.prepare(\"SELECT * FROM users\")", "        query.bind(\"email\", email)", "        return query.fetch_one()"],
	["func setup_middleware(app: Application):", "    app.use(cors_handler)", "    app.use(rate_limiter(100, 60))", "    app.use(auth_middleware)", "    app.use(request_logger)"],
	["async func fetch_dashboard_data(user_id: int):", "    var tasks = await api.get(\"/tasks/\" + str(user_id))", "    var stats = await api.get(\"/stats/\" + str(user_id))", "    return { \"tasks\": tasks, \"stats\": stats }"],
	["func run_migration_003():", "    db.execute(\"ALTER TABLE users ADD COLUMN role TEXT\")", "    db.execute(\"UPDATE users SET role = 'member'\")", "    db.execute(\"CREATE INDEX idx_users_role ON users(role)\")"],
	["func calculate_invoice(hours: float, rate: float) -> Dictionary:", "    var subtotal = hours * rate", "    var tax = subtotal * 0.21", "    var total = subtotal + tax", "    return {\"subtotal\": subtotal, \"tax\": tax, \"total\": total}"],
]

static func get_random_snippet() -> Array:
	return SNIPPETS[randi() % SNIPPETS.size()]
```

**Step 2: Create IDE interface scene**

Create `src/ide/ide_interface.tscn`:
```
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/ide/ide_interface.gd" id="1"]

[node name="IDEInterface" type="PanelContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1")
```

**Step 3: Create IDE interface script**

Create `src/ide/ide_interface.gd`:
```gdscript
extends PanelContainer

var coding_loop: CodingLoop = CodingLoop.new()
var current_snippet: Array = []
var lines_revealed: int = 0
var click_power: float = 1.0

@onready var code_display: RichTextLabel
@onready var progress_bar: ProgressBar
@onready var action_button: Button
@onready var status_label: Label
@onready var task_label: Label
@onready var review_panel: VBoxContainer
@onready var conflict_panel: HBoxContainer

func _ready():
	_build_ui()
	_connect_signals()

func _build_ui():
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 16)
	margin.add_theme_constant_override("margin_right", 16)
	margin.add_theme_constant_override("margin_top", 16)
	margin.add_theme_constant_override("margin_bottom", 16)
	add_child(margin)

	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 8)
	margin.add_child(vbox)

	# Title bar
	var title_bar = HBoxContainer.new()
	vbox.add_child(title_bar)
	var title = Label.new()
	title.text = "  CONSULTANCY IDE v1.0"
	title.add_theme_font_size_override("font_size", 14)
	title_bar.add_child(title)

	# Task label
	task_label = Label.new()
	task_label.text = "No active task"
	vbox.add_child(task_label)

	# Status
	status_label = Label.new()
	status_label.text = "IDLE"
	vbox.add_child(status_label)

	# Code display
	code_display = RichTextLabel.new()
	code_display.bbcode_enabled = true
	code_display.custom_minimum_size = Vector2(0, 300)
	code_display.size_flags_vertical = Control.SIZE_EXPAND_FILL
	code_display.add_theme_color_override("default_color", Color(0.85, 0.85, 0.85))
	vbox.add_child(code_display)

	# Progress bar
	progress_bar = ProgressBar.new()
	progress_bar.min_value = 0.0
	progress_bar.max_value = 1.0
	progress_bar.step = 0.01
	progress_bar.custom_minimum_size = Vector2(0, 24)
	vbox.add_child(progress_bar)

	# Review panel (hidden by default)
	review_panel = VBoxContainer.new()
	review_panel.visible = false
	vbox.add_child(review_panel)

	# Conflict panel (hidden by default)
	conflict_panel = HBoxContainer.new()
	conflict_panel.visible = false
	vbox.add_child(conflict_panel)

	# Action button
	action_button = Button.new()
	action_button.text = "Write Code"
	action_button.custom_minimum_size = Vector2(0, 48)
	action_button.pressed.connect(_on_action_pressed)
	vbox.add_child(action_button)

func _connect_signals():
	coding_loop.state_changed.connect(_on_state_changed)
	coding_loop.progress_changed.connect(_on_progress_changed)
	coding_loop.conflict_appeared.connect(_on_conflict_appeared)
	coding_loop.task_done.connect(_on_task_done)

func start_task(task: CodingTask):
	current_snippet = FakeCode.get_random_snippet()
	lines_revealed = 0
	code_display.text = ""
	coding_loop.start_task(task)
	task_label.text = "Task: " + task.title
	_update_ui()

func _on_action_pressed():
	match coding_loop.state:
		CodingLoop.State.WRITING:
			coding_loop.perform_click(click_power)
			_reveal_code_line()
		CodingLoop.State.REVIEWING:
			_do_review()
		CodingLoop.State.FIXING:
			coding_loop.perform_click(click_power)
		CodingLoop.State.IDLE:
			pass  # handled externally (bidding system starts tasks)

func _reveal_code_line():
	if lines_revealed < current_snippet.size():
		var line = current_snippet[lines_revealed]
		var colored = _syntax_highlight(line)
		code_display.append_text(colored + "\n")
		lines_revealed += 1

func _syntax_highlight(line: String) -> String:
	var result = line
	# Keywords
	for kw in ["func", "var", "return", "if", "else", "for", "class", "async", "await", "const"]:
		result = result.replace(kw + " ", "[color=#569cd6]" + kw + "[/color] ")
	# Strings
	var string_regex = RegEx.new()
	string_regex.compile("\"[^\"]*\"")
	for m in string_regex.search_all(result):
		result = result.replace(m.get_string(), "[color=#ce9178]" + m.get_string() + "[/color]")
	return result

func _do_review():
	var reject_chance = coding_loop.current_task.get_review_reject_chance()
	# Player skill reduces reject chance
	var skill_modifier = GameState.get_skill_level("code_quality") * 0.05
	var approved = randf() > (reject_chance - skill_modifier)
	coding_loop.resolve_review(approved)
	if approved:
		_show_review_comment("[color=#4ec9b0]Reviewer:[/color] LGTM! Approved.")
	else:
		_show_review_comment("[color=#f44747]Reviewer:[/color] Changes requested. Please fix.")

func _show_review_comment(text: String):
	for child in review_panel.get_children():
		child.queue_free()
	var label = RichTextLabel.new()
	label.bbcode_enabled = true
	label.text = text
	label.fit_content = true
	label.custom_minimum_size = Vector2(0, 40)
	review_panel.add_child(label)
	review_panel.visible = true

func _on_conflict_appeared(left_code: String, right_code: String):
	conflict_panel.visible = true
	for child in conflict_panel.get_children():
		child.queue_free()

	var left_btn = Button.new()
	left_btn.text = "Accept Local\n" + left_code
	left_btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	left_btn.pressed.connect(func(): coding_loop.resolve_conflict("left"))
	conflict_panel.add_child(left_btn)

	var right_btn = Button.new()
	right_btn.text = "Accept Remote\n" + right_code
	right_btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	right_btn.pressed.connect(func(): coding_loop.resolve_conflict("right"))
	conflict_panel.add_child(right_btn)

func _on_state_changed(new_state: CodingLoop.State):
	_update_ui()

func _on_progress_changed(new_progress: float):
	progress_bar.value = new_progress

func _on_task_done(task: CodingTask):
	GameState.add_money(task.payout)
	GameState.add_reputation(task.difficulty * 1.0)
	status_label.text = "COMPLETE — Earned $%.0f" % task.payout
	review_panel.visible = false
	conflict_panel.visible = false

func _update_ui():
	conflict_panel.visible = false
	review_panel.visible = false
	match coding_loop.state:
		CodingLoop.State.IDLE:
			status_label.text = "IDLE — Waiting for task"
			action_button.text = "Waiting..."
			action_button.disabled = true
		CodingLoop.State.WRITING:
			status_label.text = "WRITING CODE"
			action_button.text = "Write Code [Click!]"
			action_button.disabled = false
		CodingLoop.State.REVIEWING:
			status_label.text = "CODE REVIEW"
			action_button.text = "Submit for Review"
			action_button.disabled = false
			review_panel.visible = true
		CodingLoop.State.FIXING:
			status_label.text = "FIXING — %d changes remaining" % coding_loop.review_changes_needed
			action_button.text = "Fix Code [Click!]"
			action_button.disabled = false
		CodingLoop.State.CONFLICT:
			status_label.text = "MERGE CONFLICT — Pick a side"
			action_button.visible = false
			conflict_panel.visible = true
		CodingLoop.State.COMPLETE:
			action_button.text = "Complete!"
			action_button.disabled = true

func set_click_power(power: float):
	click_power = power
```

**Step 4: Manual test — open in Godot editor and verify UI renders**

Run: `godot --path "$PWD" --editor` — open the `ide_interface.tscn` scene, verify it shows the panel structure.

**Step 5: Commit**

```bash
git add src/ide/
git commit -m "feat: add IDE interface with code writing, review, and conflict UI"
```

---

### Task 6: Client Bidding System

**Files:**
- Create: `src/data/client_contract.gd`
- Create: `src/logic/bidding_system.gd`
- Create: `test/unit/test_bidding.gd`
- Create: `src/ui/bidding_panel.gd`
- Create: `src/ui/bidding_panel.tscn`

**Step 1: Write failing tests**

Create `test/unit/test_bidding.gd`:
```gdscript
extends GutTest

func test_contract_creation():
	var contract = load("res://src/data/client_contract.gd").new()
	contract.client_name = "FinApp"
	contract.project_description = "REST API refactor"
	contract.tier = 2
	contract.task_count = 5
	contract.required_skills = {"python": 2}
	assert_eq(contract.client_name, "FinApp")
	assert_eq(contract.tier, 2)

func test_bid_success_high_skill():
	var system = load("res://src/logic/bidding_system.gd").new()
	var contract = load("res://src/data/client_contract.gd").new()
	contract.required_skills = {"python": 2}
	# High skill -> high chance
	var chance = system.calculate_bid_chance(contract, {"python": 5})
	assert_gt(chance, 0.7, "High skill should give high bid chance")

func test_bid_success_low_skill():
	var system = load("res://src/logic/bidding_system.gd").new()
	var contract = load("res://src/data/client_contract.gd").new()
	contract.required_skills = {"python": 5}
	# Low skill -> low chance
	var chance = system.calculate_bid_chance(contract, {"python": 1})
	assert_lt(chance, 0.4, "Low skill should give low bid chance")

func test_bid_success_no_skill():
	var system = load("res://src/logic/bidding_system.gd").new()
	var contract = load("res://src/data/client_contract.gd").new()
	contract.required_skills = {"python": 3}
	var chance = system.calculate_bid_chance(contract, {})
	assert_lt(chance, 0.2, "No matching skill should give very low chance")

func test_contract_difficulty_modifier():
	var system = load("res://src/logic/bidding_system.gd").new()
	var contract = load("res://src/data/client_contract.gd").new()
	contract.required_skills = {"python": 5}
	# Underskilled contract should increase task difficulty
	var modifier = system.get_difficulty_modifier(contract, {"python": 2})
	assert_gt(modifier, 1.0, "Underskilled should increase difficulty")

func test_generate_contracts():
	var system = load("res://src/logic/bidding_system.gd").new()
	var contracts = system.generate_contracts(3, 5.0)
	assert_eq(contracts.size(), 3)
	for c in contracts:
		assert_ne(c.client_name, "")
		assert_gt(c.task_count, 0)
```

**Step 2: Run tests to verify they fail**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: FAIL

**Step 3: Create ClientContract resource**

Create `src/data/client_contract.gd`:
```gdscript
extends Resource
class_name ClientContract

var client_name: String = ""
var project_description: String = ""
var tier: int = 1  # 1=freelance, 2=short-term, 3=retainer, 4=SaaS
var task_count: int = 1
var payout_per_task: float = 25.0
var required_skills: Dictionary = {}  # skill_id -> min_level
var duration: float = 60.0  # seconds before offer expires

func get_total_value() -> float:
	return task_count * payout_per_task
```

**Step 4: Create BiddingSystem**

Create `src/logic/bidding_system.gd`:
```gdscript
extends RefCounted
class_name BiddingSystem

const CLIENT_NAMES = [
	"FinApp", "HealthBase", "ShopStream", "DataPulse", "CloudNine",
	"LogiTrack", "PayRight", "SecureNet", "DevFlow", "MetricHub",
	"TaskForge", "CodeBridge", "SyncWave", "BuildStack", "ApiNest",
]

const PROJECT_TYPES = [
	"REST API refactor", "payment integration", "auth system overhaul",
	"dashboard rebuild", "database migration", "CI/CD pipeline setup",
	"search feature", "notification service", "analytics module",
	"performance optimization", "security audit fixes", "mobile API",
]

const SKILL_POOL = ["javascript", "python", "rust", "go", "devops", "frameworks"]

func calculate_bid_chance(contract: ClientContract, player_skills: Dictionary) -> float:
	if contract.required_skills.is_empty():
		return 0.9

	var total_gap: float = 0.0
	var skill_count: int = 0
	for skill_id in contract.required_skills:
		var required = contract.required_skills[skill_id]
		var player_level = player_skills.get(skill_id, 0)
		total_gap += maxf(required - player_level, 0)
		skill_count += 1

	if skill_count == 0:
		return 0.9

	var avg_gap = total_gap / skill_count
	return clampf(0.9 - avg_gap * 0.2, 0.05, 0.95)

func get_difficulty_modifier(contract: ClientContract, player_skills: Dictionary) -> float:
	var total_gap: float = 0.0
	for skill_id in contract.required_skills:
		var required = contract.required_skills[skill_id]
		var player_level = player_skills.get(skill_id, 0)
		total_gap += maxf(required - player_level, 0)
	return 1.0 + total_gap * 0.3

func generate_contracts(count: int, reputation: float) -> Array[ClientContract]:
	var contracts: Array[ClientContract] = []
	var max_tier = clampi(int(reputation / 20.0) + 1, 1, 4)
	for i in range(count):
		var contract = ClientContract.new()
		contract.client_name = CLIENT_NAMES[randi() % CLIENT_NAMES.size()]
		contract.project_description = PROJECT_TYPES[randi() % PROJECT_TYPES.size()]
		contract.tier = clampi(randi_range(1, max_tier), 1, 4)
		contract.task_count = contract.tier * 2 + randi_range(1, 3)
		contract.payout_per_task = contract.tier * 25.0 + randf_range(0, contract.tier * 15.0)
		# Assign 1-2 required skills
		var num_skills = randi_range(1, mini(2, SKILL_POOL.size()))
		var shuffled = SKILL_POOL.duplicate()
		shuffled.shuffle()
		for j in range(num_skills):
			contract.required_skills[shuffled[j]] = randi_range(1, contract.tier * 2)
		contract.duration = 120.0 - contract.tier * 15.0
		contracts.append(contract)
	return contracts

func attempt_bid(contract: ClientContract, player_skills: Dictionary) -> bool:
	var chance = calculate_bid_chance(contract, player_skills)
	return randf() < chance
```

**Step 5: Run tests to verify they pass**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All pass

**Step 6: Create bidding panel UI**

Create `src/ui/bidding_panel.tscn`:
```
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/ui/bidding_panel.gd" id="1"]

[node name="BiddingPanel" type="PanelContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
script = ExtResource("1")
```

Create `src/ui/bidding_panel.gd`:
```gdscript
extends PanelContainer

var bidding_system: BiddingSystem = BiddingSystem.new()
var active_contracts: Array[ClientContract] = []
var contract_list: VBoxContainer

signal contract_accepted(contract: ClientContract, difficulty_modifier: float)

func _ready():
	_build_ui()

func _build_ui():
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 12)
	margin.add_theme_constant_override("margin_right", 12)
	margin.add_theme_constant_override("margin_top", 12)
	margin.add_theme_constant_override("margin_bottom", 12)
	add_child(margin)

	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 8)
	margin.add_child(vbox)

	var title = Label.new()
	title.text = "Available Contracts"
	title.add_theme_font_size_override("font_size", 18)
	vbox.add_child(title)

	contract_list = VBoxContainer.new()
	contract_list.add_theme_constant_override("separation", 4)
	vbox.add_child(contract_list)

func refresh_contracts():
	active_contracts = bidding_system.generate_contracts(3, GameState.reputation)
	_display_contracts()

func _display_contracts():
	for child in contract_list.get_children():
		child.queue_free()

	for contract in active_contracts:
		var card = _create_contract_card(contract)
		contract_list.add_child(card)

func _create_contract_card(contract: ClientContract) -> PanelContainer:
	var card = PanelContainer.new()
	var hbox = HBoxContainer.new()
	hbox.add_theme_constant_override("separation", 12)
	card.add_child(hbox)

	var info = VBoxContainer.new()
	info.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	hbox.add_child(info)

	var name_label = Label.new()
	name_label.text = "%s — %s" % [contract.client_name, contract.project_description]
	info.add_child(name_label)

	var details_label = Label.new()
	var tier_names = ["", "Freelance", "Short-term", "Retainer", "SaaS"]
	var skills_text = ", ".join(contract.required_skills.keys()) if not contract.required_skills.is_empty() else "none"
	details_label.text = "%s | %d tasks | $%.0f/task | Skills: %s" % [
		tier_names[contract.tier], contract.task_count,
		contract.payout_per_task, skills_text
	]
	details_label.add_theme_font_size_override("font_size", 12)
	info.add_child(details_label)

	var bid_chance = bidding_system.calculate_bid_chance(contract, GameState.skills)
	var chance_label = Label.new()
	chance_label.text = "%.0f%% chance" % (bid_chance * 100)
	hbox.add_child(chance_label)

	var bid_btn = Button.new()
	bid_btn.text = "Bid"
	bid_btn.pressed.connect(func(): _on_bid(contract))
	hbox.add_child(bid_btn)

	return card

func _on_bid(contract: ClientContract):
	var success = bidding_system.attempt_bid(contract, GameState.skills)
	if success:
		var diff_mod = bidding_system.get_difficulty_modifier(contract, GameState.skills)
		active_contracts.erase(contract)
		_display_contracts()
		contract_accepted.emit(contract, diff_mod)
	else:
		# Show failure feedback
		active_contracts.erase(contract)
		_display_contracts()
```

**Step 7: Commit**

```bash
git add src/data/client_contract.gd src/logic/bidding_system.gd src/ui/ test/unit/test_bidding.gd
git commit -m "feat: add client bidding system with contracts and bid mechanics"
```

---

### Task 7: Basic Skill System

**Files:**
- Create: `src/data/skill_data.gd`
- Create: `src/logic/skill_manager.gd`
- Create: `test/unit/test_skills.gd`
- Create: `src/ui/skill_panel.gd`
- Create: `src/ui/skill_panel.tscn`

**Step 1: Write failing tests**

Create `test/unit/test_skills.gd`:
```gdscript
extends GutTest

var manager

func before_each():
	manager = load("res://src/logic/skill_manager.gd").new()

func test_get_available_skills():
	var skills = manager.get_all_skills()
	assert_gt(skills.size(), 0, "Should have skills defined")

func test_skill_has_required_fields():
	var skills = manager.get_all_skills()
	var skill = skills[0]
	assert_ne(skill.id, "", "Skill should have id")
	assert_ne(skill.name, "", "Skill should have name")
	assert_gt(skill.cost, 0.0, "Skill should have positive cost")
	assert_gt(skill.max_level, 0, "Skill should have max level")

func test_can_purchase_with_enough_money():
	var state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)
	state.money = 500.0
	var skills = manager.get_all_skills()
	var result = manager.try_purchase(skills[0], state)
	assert_true(result, "Should be able to purchase with enough money")

func test_cannot_purchase_without_money():
	var state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)
	state.money = 0.0
	var skills = manager.get_all_skills()
	var result = manager.try_purchase(skills[0], state)
	assert_false(result, "Should not purchase without money")

func test_purchase_increases_skill_level():
	var state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)
	state.money = 500.0
	var skills = manager.get_all_skills()
	manager.try_purchase(skills[0], state)
	assert_eq(state.get_skill_level(skills[0].id), 1)

func test_cannot_exceed_max_level():
	var state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)
	state.money = 99999.0
	var skills = manager.get_all_skills()
	var skill = skills[0]
	for i in range(skill.max_level + 3):
		manager.try_purchase(skill, state)
	assert_eq(state.get_skill_level(skill.id), skill.max_level)

func test_click_power_calculation():
	var state = load("res://src/autoload/game_state.gd").new()
	add_child_autofree(state)
	var base_power = manager.calculate_click_power(state)
	state.set_skill_level("coding_speed", 3)
	var boosted_power = manager.calculate_click_power(state)
	assert_gt(boosted_power, base_power, "Skill should increase click power")
```

**Step 2: Run tests to verify they fail**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: FAIL

**Step 3: Create SkillData resource**

Create `src/data/skill_data.gd`:
```gdscript
extends Resource
class_name SkillData

var id: String = ""
var name: String = ""
var description: String = ""
var category: String = ""  # "language", "framework", "soft_skill"
var cost: float = 100.0
var cost_multiplier: float = 1.8  # each level costs more
var max_level: int = 5

func get_cost_for_level(current_level: int) -> float:
	return cost * pow(cost_multiplier, current_level)
```

**Step 4: Create SkillManager**

Create `src/logic/skill_manager.gd`:
```gdscript
extends RefCounted
class_name SkillManager

var _skills: Array[SkillData] = []

func _init():
	_define_skills()

func _define_skills():
	_skills.append(_make_skill("coding_speed", "Coding Speed", "Write code faster — more progress per click", "soft_skill", 50.0, 5))
	_skills.append(_make_skill("code_quality", "Code Quality", "Fewer review rejections", "soft_skill", 75.0, 5))
	_skills.append(_make_skill("javascript", "JavaScript", "Unlocks web development contracts", "language", 100.0, 5))
	_skills.append(_make_skill("python", "Python", "Unlocks data and backend contracts", "language", 100.0, 5))
	_skills.append(_make_skill("devops", "DevOps", "Reduces CI failure chance", "framework", 150.0, 5))
	_skills.append(_make_skill("frameworks", "Frameworks", "Unlocks higher-tier contracts", "framework", 120.0, 5))
	_skills.append(_make_skill("negotiation", "Negotiation", "Better bidding success rates", "soft_skill", 80.0, 3))

func _make_skill(id: String, skill_name: String, desc: String, cat: String, base_cost: float, max_lvl: int) -> SkillData:
	var s = SkillData.new()
	s.id = id
	s.name = skill_name
	s.description = desc
	s.category = cat
	s.cost = base_cost
	s.max_level = max_lvl
	return s

func get_all_skills() -> Array[SkillData]:
	return _skills

func try_purchase(skill: SkillData, state: Node) -> bool:
	var current_level = state.get_skill_level(skill.id)
	if current_level >= skill.max_level:
		return false
	var price = skill.get_cost_for_level(current_level)
	if not state.spend_money(price):
		return false
	state.set_skill_level(skill.id, current_level + 1)
	return true

func calculate_click_power(state: Node) -> float:
	return 1.0 + state.get_skill_level("coding_speed") * 0.3

func calculate_review_bonus(state: Node) -> float:
	return state.get_skill_level("code_quality") * 0.05

func calculate_bid_bonus(state: Node) -> float:
	return state.get_skill_level("negotiation") * 0.08
```

**Step 5: Run tests to verify they pass**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All pass

**Step 6: Create skill panel UI**

Create `src/ui/skill_panel.tscn`:
```
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/ui/skill_panel.gd" id="1"]

[node name="SkillPanel" type="PanelContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
script = ExtResource("1")
```

Create `src/ui/skill_panel.gd`:
```gdscript
extends PanelContainer

var skill_manager: SkillManager = SkillManager.new()
var skill_list: VBoxContainer

func _ready():
	_build_ui()
	refresh()

func _build_ui():
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 12)
	margin.add_theme_constant_override("margin_right", 12)
	margin.add_theme_constant_override("margin_top", 12)
	margin.add_theme_constant_override("margin_bottom", 12)
	add_child(margin)

	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 8)
	margin.add_child(vbox)

	var title = Label.new()
	title.text = "Skills & Certifications"
	title.add_theme_font_size_override("font_size", 18)
	vbox.add_child(title)

	skill_list = VBoxContainer.new()
	skill_list.add_theme_constant_override("separation", 4)
	vbox.add_child(skill_list)

func refresh():
	for child in skill_list.get_children():
		child.queue_free()

	for skill in skill_manager.get_all_skills():
		var row = _create_skill_row(skill)
		skill_list.add_child(row)

func _create_skill_row(skill: SkillData) -> HBoxContainer:
	var row = HBoxContainer.new()
	row.add_theme_constant_override("separation", 8)

	var current_level = GameState.get_skill_level(skill.id)

	var name_label = Label.new()
	name_label.text = "%s (Lv %d/%d)" % [skill.name, current_level, skill.max_level]
	name_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	row.add_child(name_label)

	var desc_label = Label.new()
	desc_label.text = skill.description
	desc_label.add_theme_font_size_override("font_size", 12)
	desc_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	row.add_child(desc_label)

	var buy_btn = Button.new()
	if current_level >= skill.max_level:
		buy_btn.text = "MAX"
		buy_btn.disabled = true
	else:
		var price = skill.get_cost_for_level(current_level)
		buy_btn.text = "Buy $%.0f" % price
		buy_btn.pressed.connect(func():
			skill_manager.try_purchase(skill, GameState)
			refresh()
		)
	row.add_child(buy_btn)

	return row
```

**Step 7: Commit**

```bash
git add src/data/skill_data.gd src/logic/skill_manager.gd src/ui/skill_panel.gd src/ui/skill_panel.tscn test/unit/test_skills.gd
git commit -m "feat: add skill system with 7 starter skills and purchase UI"
```

---

### Task 8: HUD

**Files:**
- Create: `src/ui/hud.gd`
- Create: `src/ui/hud.tscn`

**Step 1: Create HUD scene**

Create `src/ui/hud.tscn`:
```
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/ui/hud.gd" id="1"]

[node name="HUD" type="HBoxContainer"]
anchors_preset = 10
anchor_right = 1.0
offset_bottom = 40.0
grow_horizontal = 2
script = ExtResource("1")
```

**Step 2: Create HUD script**

Create `src/ui/hud.gd`:
```gdscript
extends HBoxContainer

var money_label: Label
var reputation_label: Label
var task_label: Label

func _ready():
	_build_ui()
	EventBus.money_changed.connect(_on_money_changed)
	EventBus.reputation_changed.connect(_on_reputation_changed)
	_on_money_changed(GameState.money)
	_on_reputation_changed(GameState.reputation)

func _build_ui():
	add_theme_constant_override("separation", 24)

	money_label = Label.new()
	money_label.text = "$0"
	money_label.add_theme_font_size_override("font_size", 20)
	add_child(money_label)

	reputation_label = Label.new()
	reputation_label.text = "Rep: 0"
	reputation_label.add_theme_font_size_override("font_size", 20)
	add_child(reputation_label)

	task_label = Label.new()
	task_label.text = ""
	task_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	task_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	add_child(task_label)

func _on_money_changed(amount: float):
	money_label.text = "$%.0f" % amount

func _on_reputation_changed(amount: float):
	reputation_label.text = "Rep: %.0f" % amount

func set_task_info(text: String):
	task_label.text = text
```

**Step 3: Commit**

```bash
git add src/ui/hud.gd src/ui/hud.tscn
git commit -m "feat: add HUD with money and reputation display"
```

---

### Task 9: Main Scene — Wire Everything Together

**Files:**
- Create: `src/main.gd`
- Create: `src/main.tscn`
- Modify: `project.godot`

**Step 1: Create main scene**

Create `src/main.tscn`:
```
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/main.gd" id="1"]

[node name="Main" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1")
```

**Step 2: Create main script**

Create `src/main.gd`:
```gdscript
extends Control

enum View { IDE, BIDDING, SKILLS }

var current_view: View = View.BIDDING
var ide: PanelContainer
var bidding_panel: PanelContainer
var skill_panel: PanelContainer
var hud: HBoxContainer
var nav_bar: HBoxContainer
var task_factory: TaskFactory = TaskFactory.new()
var skill_manager: SkillManager = SkillManager.new()

# Active contract tracking
var active_contract: ClientContract = null
var tasks_remaining: int = 0
var difficulty_modifier: float = 1.0
var contract_offer_timer: Timer

func _ready():
	_build_layout()
	_connect_signals()
	_setup_contract_timer()
	_show_view(View.BIDDING)
	bidding_panel.refresh_contracts()

func _build_layout():
	var bg = ColorRect.new()
	bg.color = Color(0.12, 0.12, 0.15)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	add_child(bg)

	var vbox = VBoxContainer.new()
	vbox.set_anchors_preset(Control.PRESET_FULL_RECT)
	vbox.add_theme_constant_override("separation", 0)
	add_child(vbox)

	# HUD
	hud = load("res://src/ui/hud.tscn").instantiate()
	vbox.add_child(hud)

	# Nav bar
	nav_bar = HBoxContainer.new()
	nav_bar.add_theme_constant_override("separation", 4)
	vbox.add_child(nav_bar)

	var ide_btn = Button.new()
	ide_btn.text = "IDE"
	ide_btn.pressed.connect(func(): _show_view(View.IDE))
	nav_bar.add_child(ide_btn)

	var bid_btn = Button.new()
	bid_btn.text = "Contracts"
	bid_btn.pressed.connect(func(): _show_view(View.BIDDING))
	nav_bar.add_child(bid_btn)

	var skill_btn = Button.new()
	skill_btn.text = "Skills"
	skill_btn.pressed.connect(func(): _show_view(View.SKILLS))
	nav_bar.add_child(skill_btn)

	# Content area
	var content = Control.new()
	content.size_flags_vertical = Control.SIZE_EXPAND_FILL
	vbox.add_child(content)

	# IDE
	ide = load("res://src/ide/ide_interface.tscn").instantiate()
	ide.set_anchors_preset(Control.PRESET_FULL_RECT)
	content.add_child(ide)

	# Bidding panel
	bidding_panel = load("res://src/ui/bidding_panel.tscn").instantiate()
	bidding_panel.set_anchors_preset(Control.PRESET_FULL_RECT)
	content.add_child(bidding_panel)

	# Skill panel
	skill_panel = load("res://src/ui/skill_panel.tscn").instantiate()
	skill_panel.set_anchors_preset(Control.PRESET_FULL_RECT)
	content.add_child(skill_panel)

func _connect_signals():
	bidding_panel.contract_accepted.connect(_on_contract_accepted)
	ide.coding_loop.task_done.connect(_on_task_completed)
	EventBus.skill_purchased.connect(func(_id): _update_click_power())

func _setup_contract_timer():
	contract_offer_timer = Timer.new()
	contract_offer_timer.wait_time = 30.0
	contract_offer_timer.autostart = true
	contract_offer_timer.timeout.connect(func(): bidding_panel.refresh_contracts())
	add_child(contract_offer_timer)

func _show_view(view: View):
	current_view = view
	ide.visible = view == View.IDE
	bidding_panel.visible = view == View.BIDDING
	skill_panel.visible = view == View.SKILLS
	if view == View.SKILLS:
		skill_panel.refresh()

func _on_contract_accepted(contract: ClientContract, diff_mod: float):
	active_contract = contract
	tasks_remaining = contract.task_count
	difficulty_modifier = diff_mod
	_update_click_power()
	_start_next_task()
	_show_view(View.IDE)

func _start_next_task():
	if tasks_remaining <= 0:
		_on_contract_finished()
		return
	var tier = active_contract.tier
	var task = task_factory.generate_task(tier)
	task.payout = active_contract.payout_per_task
	# Apply difficulty modifier from skill gap
	task.difficulty = clampi(roundi(task.difficulty * difficulty_modifier), 1, 10)
	task.total_clicks = roundi(task.total_clicks * difficulty_modifier)
	hud.set_task_info("%s — Task %d/%d" % [
		active_contract.client_name,
		active_contract.task_count - tasks_remaining + 1,
		active_contract.task_count
	])
	ide.start_task(task)

func _on_task_completed(_task: CodingTask):
	tasks_remaining -= 1
	if tasks_remaining > 0:
		# Small delay before next task
		var delay = get_tree().create_timer(1.5)
		delay.timeout.connect(_start_next_task)
	else:
		_on_contract_finished()

func _on_contract_finished():
	active_contract = null
	hud.set_task_info("Contract complete! Find a new one.")
	_show_view(View.BIDDING)
	bidding_panel.refresh_contracts()

func _update_click_power():
	ide.set_click_power(skill_manager.calculate_click_power(GameState))
```

**Step 3: Set main scene in project.godot**

Add/modify in `project.godot` under `[application]`:
```ini
run/main_scene="res://src/main.tscn"
```

**Step 4: Run the game**

Run: `godot --path "$PWD"`
Expected: Game launches. You see the bidding panel with 3 contracts. Click "Bid" to accept one. IDE view appears with a coding task. Click to write code. Submit for review. Complete task. Get paid. Repeat.

**Step 5: Commit**

```bash
git add src/main.gd src/main.tscn project.godot
git commit -m "feat: wire up main scene with IDE, bidding, skills, and HUD"
```

---

### Task 10: Run Full Test Suite & Final Verification

**Step 1: Run all tests**

Run: `godot --headless -s addons/gut/gut_cmdln.gd`
Expected: All tests pass (smoke, game_state, coding_task, coding_loop, bidding, skills)

**Step 2: Play-test the full loop**

Run: `godot --path "$PWD"`

Verify:
- [ ] Bidding panel shows 3 contracts with skill requirements and bid chances
- [ ] Bidding succeeds/fails based on displayed chance
- [ ] IDE shows task title and status
- [ ] Clicking "Write Code" fills progress bar and reveals fake code
- [ ] Review phase shows approval or rejection
- [ ] Rejected code enters fixing state requiring clicks
- [ ] Merge conflicts appear occasionally (not every task)
- [ ] Completing a task awards money (visible in HUD)
- [ ] Reputation increases after tasks
- [ ] Skills panel shows all 7 skills with prices
- [ ] Buying a skill increases its level and deducts money
- [ ] Coding speed skill makes writing faster
- [ ] New contracts refresh periodically
- [ ] Contract completion cycles back to bidding

**Step 3: Commit any fixes**

```bash
git add -A
git commit -m "fix: playtest fixes for Phase 1 MVP"
```

**Step 4: Final commit — tag the MVP**

```bash
git tag v0.1.0-phase1-mvp
```
